# Thread & Concurrency

### concurrency(동시성)
- 응용 프로그램에서 동시성의 사용은 여러가지 이점을 가진다.
- 동시성은 병행적인 프로세스들의 집합으로서 응용 프로그램을 구조화 하면서 구현 될 수 있다.

### Overhead in Process Model
- 여러개의 프로세스를 사용하는 모델에서 각각의 프로세스는 독립적이다. 따라서 프로세스 사이의 통신에서는 IPC가 필요하고, 이는 오버헤드가 크다.
- 또한 이 모델에서 PCB(Process Context Block)는 큰 크기를 가지고 있어, 각각의 프로세스의 생성과 Context Switching엔 시간이 오래걸린다.

### What is Thread?

- 스레드는 CPU스케줄링의 기본 단위 이자 프로세스 안에서 제어의 흐름이다. 그리고 PC, 레지스터, 스택 공간으로 이루어져있어 프로세스와 비슷하지만 오버헤드를 줄일수 있을만큼 크기가 더 작다.
- 각각의 스레드는 자신만의 레지스터 상태와 스택을 가진다.
- 같은 프로세스 안에서 여러 스레드가 생성될수 있고, 프로세스를 위한 코드와 주소 공간 그리고 운영 자원을 공유할수 있다.
- 스레드가 실행되는 환경을 Task 라고 하며 전통적 프로세스는 한 스레드가 있는 하나의 Task이다.
- 스레드는 작은 Context를 사용하기에 생성과 문맥교환에 있어 비용이 절감된다.

### Single Core Multi Threading
- 병행성을 활용한다.(일련의 과정이 동시에 진행되는 것 처럼 보인다.)
    - 두 개 이상의 task가 동시에 수행되는것 처럼 보이지만 실제로는 한 시점에 한개의 프로세스만 이루어진다.
    - 특정한 Schedule에 의해 프로세스가 빠른 속도로 CPU에서 Context Switching을 하고있다.
### Multi Core Multi Threading
- 병렬성을 활용한다.
    - 하나의 프로세스에 속한 스레드들이 다른 코어에서 병렬적으로 실행 될 수 있다.


### Benefits(of threads)
- 병행성과 병렬성을 달성한다.
- 계산과 I/O를 오버랩한다.
- MP 아키텍처의 효용성을 높인다.
- 반응적이다.
- 자원을 공유한다.
- 경제적이다.

### Thread Level
스레드에는 크게 두가지 레벨이 존재한다. 
- User Level Thread
- Kernel Level Thread

### User Level Thread
- 유저 레벨에서 라이브러리 호출을 통해 커널 위에서 유지된다.
    - 스레드 관리가 유저 레벨에서 된다.
    - 커널 모드로 전환할수 없고, 빠르며 간편하다.
        - Exception Level이 다르다. 유저 레벨에서는 권한이 없어서 독자적으로 커널에 접근할수 없다
    - 어플리케이션에 특화된 스케쥴링이 가능하다.
    - Blocking Problem이 있다.
        - 한개의 스레드가 I/O를 처리하기 시작하면 다른 스레드는 다른 일을 할수 없다.
        - 멀티 프로세서의 concurrency를 유지할수 없다. 커널이 스레드의 존재를 모르기 때문이다.
    - 멀티 프로세서의 이점을 갖지 못한다.
### Kernel Level Thread
- 스레드의 스케줄링이 커널에 의해 관리 된다.
- 유저 레벨 스레드와 비교하면 느리다.
- Blocking Problem이 존재하지 않는다.
- 대부분의 현대 OS들은 커널을 지원한다.

>  Blocking Problem은 동기화 관련된 문제를 말한다. Ex) Blocking or Non-Blocking
