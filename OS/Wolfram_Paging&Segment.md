# 페이징

외부 단편화로 인한 메모리 낭비는 굉장히 심각하다는 것을 이미 알고있다.
Compaction(압축) 을 사용하면 외부 단편화 문제는 해결할순 있지만 그로 인해 발생하는 오버헤드와 비효율적인 성능은 OS를 사용하기 어렵게 만든다.

그 이후에 연구를 통해 나온것이 Paging이다. 페이징은 Hole을 가지고 해결하는 것이 아니라, 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려 했다.

페이징은 프로세스를 일정한 작은 크기로 나눈다.
프로세스 뿐 아니라 hole역시 같은 크기로 나누게 된다.
이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다.
하지만 한개의 프로세스는 연속적인 동작을 수행하는데, 이를 작은 조각으로 나누어 여기저기 흩뿌려지면 프로세스는 과연 정상적으로 작동을 할까?

메모리상에 여러곳에 흩뿌려진 프로세스를 회수하고 수행시키기 위해 CPU를 속여야만 한다.
이전에 다중 프로그래밍을 살펴봤을 때, MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했다.
이 역시 CPU를 속이는 행위다. 실제 메모리는 연속적이지 않고, CPU는 연속적으로 사용하고 있다는것을 보장받으며 정상적으로 수행을 한다.

페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 가능하다.
만약 50byte의 프로세스가 있다고하고, 페이징의 크기를 각 10byte로 생각해보자.

프로세스 P1는 5개의 페이지로 나눌수있다. 이를 메인 메모리 5곳에 나눠서 할당을 하고 CPU는 논리 주소로 프로그램이 설정한 대로 연속적인 주소값으로 명령을 내리고 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어있는 테이블에서 물리 주소로 변경되어야 한다.

프로세스를 나눈 조각을 page라고 하고, 메모리를 나눈 조각을 frame이라고 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다.
프로세스를 정상적으로 사용하기 위해서는 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러개의 재배치 레지스터를 페이지 테이블이라고 한다.

### 주소 변환(Address Translation)

페이징 기법을 사용하기 위해서는 여러개로 흩어진 페이지에 CPU가 접근하기 위해 페이지 테이블을 통해 주소를 변환 시켜야 한다.

- 논리주소(Logical Address)
    - CPU가 내는 주소는 2진수로 표현되고 이때 m비트가 있다고 가정하자. 여기서 하위 n비트는 Offset 또는 변위 라고한다. 그리고 상위 m-n비트는 페이지의 번호에 해당한다.
논리주소를 물리조소로 변환하기 위해서 페이지 번호는 페이지 테이블의 인덱스 값이고, p에 해당되는 테이블 내용은 메모리의 프레임 번호다.
변위 는 변하지않는 값이다.

연속 메모리 할당을 하면서 외부 단편화가 발생하고, 이를 해결하기 위해서 페이징 기법이 나오게 되었지만 페이징은 외부 단편화가 아닌 내부 단편화 문제가 발생하게 된다.

### 내부 단편화(Internal Fragmentation)
내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채우지 못하게 된다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어지게 된다.

예를들어, 15bytes크기의 프로세스 P가 있다. 페이지 크기는 4bytes로 P를 페이지로 나누면 4 4 4 3 이되는데, 총 4개의 페이지가 만들어진다. 여기서 마지막 3bytes페이지는 프레임 크기보다 1byte가 작아서 이만큼의 공간이 비어있게된다.
이렇게 비어진 공간은 프로세스 P에서 쓰지 않고 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.

내부 단편화는 해결할 방법이 존재하지 않는다. 하지만 내부 단편화는 외부 단편화에 비해 낭비되는 공간은 매우 적다. 내부 단편화의 최대 낭비되는 크기는 page size - 1정도가 된다.
(외부 단편화는 전체 메모리의 1/3 정도를 낭비한다) 이는 굉장히 작은 값이다.

# 세그멘테이션

지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 기법이였다.
반면 세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는것을 말한다.

세그멘테이션은 프로세스를 세그먼트의 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않게된다. 프로세스를 code + data + stack으로 나누는 것 역시 세그멘테이션의 모습이다.
물론, code stack data 각각 내부에서 더 작은 세그멘트로 나눌수 있다.

세그멘테이션을 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다.
하지만 테이블은 조금 다른데, 세그멘테이션을 위한 테이블은 세그멘테이션 테이블이라고 한다.
세그멘트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)을 엔트리로 갖는다.

세그먼트에서 주소변환 역시, 페이징과 유사하다. 한가지 주의할 것은 세그먼트 크기는 일정하지 않아서 테이블에 limit정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생하고 해당 프로세스를 강제 종료시킨다.

> 세그먼트와 페이징

세그멘테이션은 페이징과 유사하고 보호와 공유에서는 조금 더 나은 성능을 보여주지만 현재 대부분은 페이징 기법을 사용한다. 이유는 세그멘테이션에선 가장 큰 단점이 있기 때문이다.

메모리 할당을 처음 시작할때 다중 프로그래밍에서의 문제점은 크기가 서로 다른 프로세스로 인해 여러크기의 hole 이 발생한다는 것이다. 이로 이냏 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 햇다.

세그멘테이션도 동일한 문제점이 발생한다. 왜냐면 세그멘테이션은 논리적인 단위로 나누기 때문에, 세그먼트 크기가 굉장히 다양하다. 이로 인해 다양한 크기의 hole이 발생하며 문제점이 발생한다.

결과적으로 세그멘테이션은 보호와 공유에서, 페이징은 외부 단편화 문제를 해결이 가능하다.
그러므로 두가지를 합쳐서 사용하는 방법이 나왔는데,  바로 세그먼트를 페이징 기법으로 나누는 것이다.

하지만 이 역시 단점이 존재하는데, 세그먼트랑 페이지가 동시에 존재하기 때문에 주소 변환도 두번을 해야한다는 것이다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 테이블에서 또 주소 변환을 해야한다.


