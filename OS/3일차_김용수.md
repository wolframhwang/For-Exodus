## Chapter3. 04. 프로세스 생성
- 유닉스같은 운영체제에서는 fork() 시스템콜을 통해서 새 프로세스를 생성함
- 부모 프로세스와 자식 프로세스는 fork()명령어 이후를 똑같이 실행함
- fork의 return 코드가 0이면 child 프로세스, 0이 아니면 parent 프로세스임
- fork 시스템 콜은 부모 프로세스는 자신의 실행을 계속 진행하거나 자식 프로세스가 실행되는 동안 wait할 수 있음
- 자식 프로세스를 기다리는 경우 waiting queue로 들어감
- 전역 변수를 자식 프로세스에서 바꾼다고 해도 부모 프로세스에는 변화가 없음(프로세스 메모리를 복제하는 것이기 때문에)
- fork()명령어를 연속해서 3번 수행할 경우에 프로세스는 총 8개가 됨
- 자식 프로세스에 다른 프로그램을 실행하게 하려면 execlp명령어를 실행하여 자식 프로세스를 덮어써주면 된다.
- execlp 아래의 명령어는 수행되지 않는다(메모리가 덮어씌워졌기 때문에)
- 자식 프로세스의 getpid()와 부모프로세스의 fork()실행한 명령어의 return 값은 같게 나온다

## Chapter3. 03-04: 퀴즈 #2
- 1번 : 프로그램이 실행되는 동안 다이나믹하게 할당되는 부분은 힙임 - 1
- 2번 : 레디 상태인데 인터럽트를 어캐걸지? - 2
- 3번 : BSS는 정적으로 할당된 세그먼트라는데 뭔진 모르겠음 - 5
- 4번 : 멀티 테스킹은 한번에 여러개처럼 하는거로 보이는거 - 2
- 5번 : WAITING 상태를 가져오는게 아니라 READY 상태를 가져오는 것 - 4
- 6번 : 부모 프로세스는 포크하고 자식 프로세스가 끝날때까지 기다린다 따라서 BD(손자)CD(자식)AD(부모) - 4
- 7번 : 1번 자식 20 2번자식 30 본인 20 - 2

## Chapter3. 05. 프로세스간 통신
- 프로세스간 통신을 IPC(Inter-Process Communication)라고 부름
- 프로세스는 독립적으로 수행되거나 협력해서 수행하는 두가지 방식이 있음
- 독립적으로 수행하는 경우에는 프로세스 스케쥴링만 잘해주면 됨
- 여러개의 프로세스가 협력해서 수행할 경우에는 협력하는 프로세스간에 커뮤니케이션을 어떻게 할 것인가도 중요함
- IPC는 데이터를 주고 받는 과정인데 데이터를 주거나 받는 동작 수행
- 두가지 모델이 존재함
  - 공유 메모리(shared memory)
  - 메시지 패싱(message passing)
- 공유 메모리 방식의 경우에 따로 공유 메모리를 지정해두어 각각 접근할 수 있도록 해주며, message passing의 경우에는 메시지 큐를 통해서 메시지 전달
- 공유 메모리의 경우 생산자 소비자 문제 고려 필요
  - 생산자는 정보를 생산하고, 소비자는 정보를 소비하는 모델
  - 생산자와 소비자 프로세스는 concurrently 하게 동작함
  - 버퍼를 사용하여 생산자는 버퍼에 데이터를 채우고, 소비자는 데이터를 소비하고 비우면 됨
  - 버퍼는 사이즈가 지정되어있기 때문에 버퍼가 가득차게되면 생산자는 wait하며, 비어있을 경우에는 소비자가 wait하고 있음
  - 순환 모형으로 버퍼를 만들어놓고 in, out의 위치를 가리키는 지시자를 만들고, in,out이 같으면 길이가 0인 것으로 판별하면 됨
- 메시지 패싱 방식은 우리는 메시지만 던지고 관리는 os가 알아서 해줌
- send(message), receive(message)만 있으면 됨
- 메시지 패싱은 두개의 프로세스말고 여러개의 프로세스가 통신하는 방식에서 메시지를 관리를 어떻게 할 것인가가 중요함
- 직접 커뮤니케이션 할것인가?, 동기적 방식으로 커뮤니케이션 할 것인가?, 자동으로 보내거나 명시적으로 버퍼링해서 보낼 것인가?
- direct 커뮤니케이션의 경우 명시적으로 상대방을 정해서 보내고, 받는 프로세스는 누구한테 받는지 명시해서 받음
- indirect 방식의 경우 원하는 mailbox에 메시지를 주고 원하는 mailbox에서 가져감
- os는 새로운 메일 박스를 만들거나 삭제하고, 메일박스에 send,receive 하는 동작으로 지원해줘야함
- blocking or non-blocking(synchronous or asynchronous) 방식
  - blocking send는 버퍼 사이즈가 부족해서 보내야하는 양을 모두 메일 박스에 보내지 못할 경우 다 보낼때까지 block됨
  - non-blocking send의 경우에는 명령어만 걸어놓고 다른 일 수행
  - receive도 동일함