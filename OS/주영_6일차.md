# OS 면접 대비 

## **`CPU스케줄링`**

-> 간단하게 요약하면 CPU를 잘 사용하기 위해 프로세스를 잘 배정하는 것 

• 목표
1. Batch System : 가능하면 많은 일을 수행. 시간보단 처리량이 중요
2. Interative System : 빠른 응답 시간. 적은 대기 시간.
3. Real-time System : 기한 맞추기

**`선점/비선점 스케줄링`** 

**선점** : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우

**비선점** : 프로세스 종료 또는 I/O 등의 이벤트가 있을 때까지 실행 보장


### **`Paging & Segmentation`**

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문

**`메모리 관리 기법`**

1. 연속 메모리 관리 
    - 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야함.
	- **고정 분할 기법** : 주기억 장치가 고정된 파티션으로 분할(내부 단편화 발생)
	- **동적 분할 기법** : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화 발생)


2.  불연속 메모리 관리
	- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
	- **페이지** : 고정 사이즈의 작은 프로세스조각
	- **프레임** : 페이지 크기와 같은 주기억장치 메모리 조각
	- **단편화** : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
	- **세그먼트** : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것

고정 크기 : 페이징(Paging)

가변 크기 : 세그멘테이션(Segmentation)

### **단순 페이징**
- 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
- 외부 단편화는 없음
- 소량의 내부 단편화 존재

### **단순 세그멘테이션**
- 각 프로세스는 여러 세그먼트들로 나뉨
- 내부 단편화는 없음, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
- 외부 단편화 존재

### **가상 메모리 페이징**
- 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 없음
- 필요한 페이지가 있으면 나중에 자동으로 불러들어짐
- 외부 단편화 없음
- 복잡한 메모리 관리로 오버헤드 발생

### **가상 메모리 세그멘테이션**
- 필요하지 않은 세그먼트들은 로드되지않음
- 필요한 세그먼트 있을 때 나중에 자동으로 불러들어짐
- 내부 단편화없음
- 복잡한 메모리 관리로 오버헤드 발생


## **`페이지 교체 알고리즘`**
페이지 부재 발생 -> 새로운 페이지 할당 -> 현재 할당된 페이지 중 어떤 것을 교체할 지 결정하는 방법

- **가상메모리**는 **demand paging**을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다. 

- 하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있다. 

- 따라서 메모리가 가득 차면 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 **out**하고, 해당 공간에 현재 필요한 페이지를 **in**시켜야 한다. 

- 여기서 어떤 페이지를 out 시켜야할지 정해야 한다. -> out되는 페이지를 **`victim page`** 라고 한다. -> 없어질 페이지 대상 또는 리스트

이러한 out을 효율적으로 효과적으로 하기 위한 알고리즘이 **`페이지 교체 알고리즘`** 이다. 

### **Page Reference String**

-> CPU는 논리 주소를 통해 특정 주소를 요구함 

메인 매모리에 올라와있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 **페이지 결함(page fault)** 가 발생하지 않는다.

따라서 CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략하여 표시하는 방법이 바로 **`Page Reference String`** 

1. **`FIFO 알고리즘`** -> 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
   - 가장 간단한 방법으로, 초기화 코드에서 적절한 방법
     - **`초기화 코드`** : 처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로, 메인 메모리에서 빼도 괜찮음. 하지만 처음 프로세스 실행시에는 무조건 필요한 코드이므로, fifo알고리즘을 사용하면 초기화를 시켜준 후 가장 먼저 내보내는 것이 가능함. 

2. **`OPT 알고리즘`** -> Optimal 알고리즘, 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄. 

    - FIFO에 비해 페이지 폴트 횟수를 많이 감소시킬 수 있음. 
    - 하지만 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려움. 

3. **`LRU 알고리즘`** -> least-Recently-Used 최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘
    - 최근에 사용하지 않았으면, 나중에도 사용되지 않을 것이라는 아이디어 
    - OPT의 경우 미래 예측이지만, LRU의 경우 과거를 보고 판단 -> 실질적으로 사용 가능 알고리즘
    - 실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높다. -> **Locality**
    - OPT보다는 페이지 폴트가 더 일어날 수 있지만, 실제로 사용할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법 중 하나

**교체 방식**
- Global 교체 : 메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식
- Local 교체 : 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

다중 프로그래밍의 경우 메인 메모리에 다양한 프로세스가 동시에 올라올 수 있음

따라서, **다양한 프로세스의 페이지가 메모리에 존재**

페이지 교체 시, 다양한 페이지 교체 알고리즘을 활용해 **victim page**를 선정하는데, 선정 기준을 Global로 하느냐 Local로 하느냐 차이



실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적이라고 함. 

자기 프로세스 페이지에서만 교체를 하면, 교체를 해야할 때 각각 모두 교체를 진행해야 하므로 비효율적

## Summary 



## Reference 
[Gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/)
