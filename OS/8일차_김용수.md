## Chapter6. 12. 동기화 문제의 해결책
- 크리티컬 섹션 문제를 해결하기위한 소프트웨어적 해결책
  - dekker's algorithm
  - bakery algorithm
  - eisenberg and mcguire's algorithm
  - peterson's algorithm(중요)
    - 임계영역 문제를 완벽하게 해결한 알고리즘이자 클래식한 소프트웨어 솔루션
- 피터슨의 알고리즘
  - critical section과 remainder section을 왔다갔다 하는 경우를 해결
  - 누구의 턴인가, 각각 프로세스의 플래그를 담을 변수 두개를 사용
  - 자신의 플래그를 true로 바꾸고 턴은 다음사람 차례로 바꿔주고 이전 프로그램의 플래그가 1이고 턴이 1인 경우 기다렸다가 완료되면 크리티컬 섹션에 접근 모두 처리후 자신의 플래그를 false로 변경, 다음 프로세스도 동일하게 동작
  - 이렇게 할 경우 동시에 접근하는 일은 없음
  - 단 피터슨 알고리즘은 제대로 동작할것이라는 보장이 없음
  - 기능적으로는 완벽하나 컨디션 체크하는 중간에 context switch가 발생할 경우에는 실패할 가능성이 있음
- 하드웨어 기반 솔루션
  - 하드웨어를 기반으로 critical section 문제를 해결해줌
  - 메모리에 방벽을 만들거나
  - 원자적으로 동작하도록 하거나(특정한 동작은 원자적으로 동작하도록 하여 중간에 context switch가 발생하지 않도록 함)


## Chapter6. 11-12: 퀴즈 #6
- 1번 : 공유변수를 바꾸는 경우에만 동기화가 필요함 - 3
- 2번 : remainder-section은 크리티컬 섹션을 접근하기 전 즉 entry-section 전에 와도 상관은 없음 - 4
- 3번 : 크리티컬 섹션 문제를 해결하는 방법에는 동시에 접근을 막기위한 상호배제, 무조건 크리티컬 섹션에 접근하려는 프로세스들 사이에서 순서를 정해 진행해야하며, 무한정 기다리게하면 안된다 - 4
- 4번 : 비선점형은 선점하고 있는 프로세스가 끝날때까지 다른 프로세스가 수행할 일이 없으므로 크리티컬 섹션 문제 발생 안함 - 2
- 5번 : a=1, b= 1, c = 1, d = 0이므로 - 1,3,4
- 6번 : 3,4,5,6,7 다 가능함 - 1,2,3,4,5
- 7번 : atomic variable은 변수의 원자성을 보장하는 명령어 - 4
- 8번 : 피터슨 알고리즘을 그대로 구현할 경우에 크리티컬 섹션에 못들어가는 경우가 생길 수 있음(context switch의 위치에 따라서) - 4

## Chapter6. 13. 뮤텍스와 세마포어
- 뮤텍스 알고리즘은 가장 간단한 동기화 방법(두개의 상태만 존재(사용중인가 아닌가))
- 세마포어는 여러개가 한번에 접근도 허용
- 모니터는 뮤텍스와 세마포어를 구현해둔 것
- 뮤텍스(mutex)
  - 뮤텍스는 상호 배제의 약자
  - 크리티컬 섹션에 들어갈 때 열쇠를 가지고 들어가고 나올 때 열쇠를 놓는다라는 방법을 사용
  - lock을 사용한다 라고 보면 됨
  - acquire 함수와 release 함수를 사용해서 들어갈때 acquire, 나올 때 release 수행
  - 쓸데없이 크리티컬 섹션의 권한을 얻기 위해서 무한루프를 도느라(spin lock) cpu의 효율이 떨어질 수 있음
  - 물론 놀고있는 코어가 여러개일 경우에는 무조건 나쁜건 아님
  - 또한 context switch가 발생하지 않기 때문에 이런점에선 효율적임
- 세마포어(semaphores)
  - n개 짜리 프로세스가 접근할 수 있도록 할 때 사용(물론 한개만 접근할 수 있다고 할 때에도 사용은 가능함)
  - 세마포어는 그냥 변수에 최대 몇개의 프로세스가 접근 가능하게 할것인가의 값으로 초기화해두고 사용
  - wait함수와 signal 함수 사용
  - wait 함수는 s가 0인 경우에는 기다렸다가 s가 1이상이 되면 s--를 해주고 크리티컬 섹션에 접근
  - signal은 critical section에서의 동작을 끝낸 후에 호출하여 s++를 해줌
  - 세마포어는 열쇠가 여러개인 방식이라고 생각하면 됨
  - 세마포어는 바이너리 세마포어와 카운팅 세마포어가 있다
  - 바이너리 세마포어는 뮤텍스와 같이 동작한다고 보면 됨
  - 카운팅 세마포어는 s의 값만큼 크리티컬 섹션에 접근 가능
  - 만약 카운팅 세마포어 내에서 두개 이상의 프로세스가 한개의 변수를 바꾸고자 하는데 특정 프로세스가 먼저 실행되길 바란다면 따로 synch 변수를 두어 0,1의 상태로 접근 허용하면 됨
  - busy waiting 을 막기위해서 wait()를 호출했는데 접근 불가능하면 waiting queue에 넣어버림