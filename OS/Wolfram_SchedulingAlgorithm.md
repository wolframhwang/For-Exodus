# 프로세스 스케줄링 알고리즘

> 프로세스 스케줄링 알고리즘

다중 프로그래밍 방식은 메모리에 여러개의 프로그램을 적재함으로서 CPU와 I/O 장치들의 유휴 시간을 줄여 사용 효율을 높이는 방식이다.
이러한 다중 프로그래밍 방식에서 CPU의 사용률과 처리율을 최대화 하기 위한 방법들을 프로세스 스케줄링 알고리즘 이라고 한다.

> 비선점(Non Preemptive)방식과 선점(Preemptive)방식의 비교

### 비 선점 형
- 프로세스가 CPU에 할당되면 권한을 빼앗을 수 없다.
- 일괄 처리 방식에 적당하다.
- 대화형, 시간 분할, 실시간 시스템엔 부적당하다.
- FIFO, SJF, HRN, 우선순위, 기한부 방식이 비 선점 형에 해당한다.
- 문맥 교환이 적어서 오버헤드가 적다.
### 선점 형
- 프로세스가 CPU에 할당될때 우선순위가 높으면 빼앗을수 있다.
- 일괄 처리방식에는 부적당하다.
- 대화형, 시간 분할, 실시간 시스템에 적당하다.
- RR, SRT, MFQ 방식이 선점형에 속한다.
- 문맥 교환이 많아서 오버헤드가 크다.

> 비선점형 방식

### FIFO(First In First Out), FCFS(First Come First Service)

- 먼저 입력된 작업을 먼저 처리하는 방식으로 가장 간단한 방법이다.
- 비선점형 방식으로 일단 한 프로세스가 CPU를 차지하면 그 프로세스가 끝날때까지 실행된다.

### FCFS의 특징
- 가장 대표적인 비 선점 형 방식이다.
- 공평하고 구현은 간편하나, 평균 반환 시간이 길어진다.
- 짧은 작업이나 중요한 작업을 오랫동안 기다리게 할수 있다.

### SJF(Short Job First)
- 작업이 끝나기 까지 실행 시간 추정치가 가장 작은 작업을 먼저 실행 시키는 방식이다.
- 비 선점 형에 해당한다.
- SJF스케줄링은 긴 작업들을 어느정도 희생시키면서 짧은 작업을 우선 처리하기에 평균 반환 시간을 최소화 할수 있다.
- 긴 작업이 CPU를 만약 점유하고있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리를 한다는 것이다.
- 만약 긴 작업인 경우에는 계속해서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고 무한 연기가 될수도 있다.
- 이러한 상태를 Starvation 현상이라고 한다.

### SJF의 특징
- 비선점형 방식이다.
- FIFO를 개선한 형태다.
- 실행 시간이 긴 작업일 경우 무한 연기가 발생할수 있음
- 평균 대기 시간을 최소화 한다.
- FIFO보다 평균 대기시간이 짧지만 긴 작업인 경우 FIFO보다 크고 예측이 더욱 어려워진다.
- 무한 연기 현상을 방지하기 위해 에이징(Aging)기법을 사용하여 해결한다.
### 무한연기 (Indefinite Postponement) 현상의 방지책 에이징 기법
- 무한 연기 현상이란 자원 할당 스케줄링 및 CPU 스케줄링 결정에 의해서 특정 프로세스가 무한정 기다리는 현상을 말한다.
- 이를 해결하기 위해 자원 할당을 오랜시간 기다린 프로세스는 기다린 시간에 비례해 높은 우선순위를 부여한다.

### HRN(Highest Response - Ratio Next) 스케줄링
 프로세스 스케줄링 방법 중 실행 시간 추정과 선점 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 하는 단점을 보완하였다.
 서비스 시간과 대기 시간의 비율을 고려한 스케줄링 방법이다.
SJF 스케줄러에서 발생할수 있는 무한 연기 현상을 극복하기 위해 개발되었다.
대기 리스트에 있는 작업들에게 합리적으로 우선순위를 부여한다.
적은 작업들의 불평등을 해소하기 위한 방식으로 SJF의 단점을 보완한 방법이다.

우선순위 = (대기 시간 + 서비스 시간) / 서비스 시간

여기서 서비스 시간이란 실행(추정) 시간과 동일한 의미다.

### HRN의 특징
- 비 선점 형 방식이다.
- SJF를 개선한 방식이다.
- 우선순위 계산 공식을 이용한다.
- 계산된 값이 가장 큰 작업에게 우선권을 부여한다.

### 우선순위 스케줄링
대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여해서 CPU를 할당하는 방식이다.
SJF 스케줄링도 작업량이 적은 작업에 우선순위를 부여했으므로, 우선순위 스케줄링의 한가지 예이다.
우선순위는 처음 순위가 결정되면 변하지않는 고정적 우선순위가 있고, 상황 변동에 잘 적응하며 처음 정해진 우선순위를 계속해서 상황에 맞게 조정하는 동적 우선순위 방식이 존재한다.
동적 우선순위 방식은 구현이 까다롭고 복잡하여 오버헤드가 크다.

### 우선순위 스케줄링 특징
- 비 선점 형 방식이다.
- 우선순위가 높은 작업을 먼저 처리하는 방식이다.
- 중요한 작업을 먼저 할 수 있는 장점이 있다.
- 기아 현상, 무한 봉쇄현상이 발생할수 있다.

### DeadLine 스케줄링

기한부 (dead line) 스케줄링은 제한된 시간 내에 반드시 작업이 완료 되도록 스케줄링하는 방식이다.
작업이 완료 되는 제한 시간을 정확히 추산하여 그 시간에 CPU사용시간을 제한한다.
작업이 제한 시간 내에 처리 되지 않는다면 해당 작업이 CPU사용 시간을 할당받을수 없는 방식이다.
이 방식은 작업이 완료되는 시기를 정확히 추정하기가 힘들며, 기한부 작업들이 한꺼번에 활성화 된다면 스케줄링은 더욱 복잡해 지고 막대한 오버헤드가 발생할수 있기 때문에 운영체제 설계자들이 주의깊게 계확하고 사용해야한다.

### Dead Line 특징
- 비 선점형 방식이다.
- 작업이 주어진 특별한 시간이나 만료 시간 안에 완료 되도록 하는 방식이다.
- 프로세스들이 마감 시간 내에 처리되지 않으면 폐기되거나 처음부터 다시 실행해야 한다.
- 기한부 스케줄링에 필요한 집약적 자원 관리는 많은 오버헤드를 일으킬수 있다.
- 동시에 다수의 기한부 작업이 수행되면 스케줄링이 어려워진다.
- 사용자는 작업에 필요한 자원의 정확한 정보를 시스템에 제시해야한다.
- 프로세스 양이 늘어나면 오버헤드 측면에서 안정적이지 못하다.

> 선점형 방식

### 라운드 로빈(Round Robin) 스케줄링
프로세스 스케줄링 방법 중 시분할 시스템을 위해 고안 되었으며, 여러개의 프로세스가 10~100ms 정도의 시간 할당량이라는 작은 단위의 시간이 정의되어 시간 할당량 만큼 CPU를 사용하는 방법이다.
먼저 입력된 작업을 먼저 처리해주는 FIFO 스케줄링을 선점형으로 변환한 방식이다.
먼저 입력된 작업이라도 할당된 시간 동안만 CPU를 사용 할수 있다.
프로세스가 CPU에서 할당한 시간이 경과할 때 까지 작업을 완료하지 못하면 CPU는 다음 대기중인 프로세스 에게로 사용 권한이 넘어가고 
현재 실행 중이던 프로세스는 대기 리스트의 가장 뒤로 배치가 된다.
여기서 할당된 시간을 TIme Slice, Quantum 이라고 하며, 이는 시스템 운영에 절대적인 영향을 미친다. 만약 할당 시간을 점점 적게 한다면 문맥 교환 횟수가 증가하게 되고 그만큼 시스템 실행 속도가 늦어지기 때문에 시스템 특성에 맞는 적절한 할당 시간 배정이 중요하다.

### Round Robin 스케줄링  특징
- FIFO방식으로 선점형 방식이다.
- 시간 할당량이 크면 비선점의 FIFO와 동일하다.
- 적절 응답 시간을 보장해주는 대화식 사용자에게 효과적이다.
- 동일한 시간을 사용하는 시 분할 시스템에 효과적이다.(시스템 측면)
- 시간 할당량이 적은 경우 문맥교환에 따른 오버헤드가 커지게 된다.

### 할당 시간과 문맥 교환 횟수
하나의 프로세스가 처음부터 완성될 때 까지 CPU를 사용한다면 PSW(Program Status Word: 프로그램 상태나 실행 번지를 기억하고 있는 레지스터) 가 기억하고 있는 실행 번지는 변하지 않습니다.
하지만 하나의 프로세스를 일정한 시간으로 분할하여 여러번에 걸쳐 CPU를 사용하게 하면 그만큼의 문맥 교환 시간이 필요하다.
시간 할당량을 적게 하면 할수록 여러개의 프로세스는 자기 혼자 CPU를 사용하는 느낌이 들게 할수 있다.
하지만 문맥 교환 횟수가 증가하므로 부가적인 시간 낭비를 초래할수 있다.

### 시간 할당이 너무 적으면?
- 프로세스간의 전이가 많아지므로 프로세스가 전이되는 과정에서 문맥 교환 횟수가 증가한다.
- 실행 시간보다 문맥 교환의 교체에 사용되는 부가적인 시간이 증가하므로 오버헤드가 커지게 된다.
- 프로세스의 교환에서 시간을 소비하고 실제 사용자들의 연산은 거의 못하는 결과를 가져온다.
### 시간 할당량이 너무 커지면?
- FIFO 방식과 거의 같은 형태가 된다.
- CPU를 사용하지 않는 시간이 많아진다.

> REFERENCE : https://blog.naver.com/adamdoha/222023047160 돌파고님의 블로그

