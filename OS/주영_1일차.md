# 면접에서 물어볼만한 개념들 정리

## 프로세스 스레드 차이 

-> 프로세스는 메모리상에서 실행중인 프로그램을 말하며, 스레드는 프로세스 안에서 실행되는 흐름 단위 

프로세스마다 최소 하나의 스레드 보유 -> 각각 별도의 주소공간을 독립적으로 할당(code, data,heap, stack) 

스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유 -> 프로세스꺼 공유


## 멀티프로세스보다 멀티스레드를 하는 이유

프로세스를 생성하여 자원을 할당하면 시스템콜이 증가하고 자원을 많이 사용하기때문에 프로세스 내에서 생성되는 스레드를 멀티로 돌리게 된다면 시스템콜도 감소하고 자원도 효율적으로 관리가 가능함. 
-> 여기서 시스템콜이란? 
시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다. 

-> 프로세스간의 통신(ipc)보다 스레드간의 통신 비용이 적어 작업들 간 부담이 감소 
대신, 멀티 스레드를 사용할 때는 공유자원으로 인한 문제 해결을 위하 동기화에 신경써야 한다. 


## 교착상태란, 4가지 조건은? 
-> 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태 
시스템적으로 한정된 자원을 여러곳에서 사용하려고 할 때 발생하는 문제로써, 
1. 상호배제 2. 점유대기 3. 비선점 4. 순환대기 이 4가지 조건을 하나라도 만족하지 않으면 ㄴ교착상태는 발생하지 않는다. 

## 페이지 교체 알고리즘
opt : 최적 교체, 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 
fifo : 할당된 수서대로
LRU : 최근에 가장 오랫동안 사용하지 않은 페이지 교체
LFU : 사용 빈도가 가장 적은 페이지 교체 
NUR : 최근에 사용하지 않은 페이지 교체 

## 가상메모리란 
-> 메모링에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메로리를 갖는 것처럼 사용할 수 있게 해주는 기법 


## 페이징, 세그멘테이션, 세마포오, 뮤텍스
페이징 : 페이지 단위의 논리-물리 주소 관리 기법. 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법 논리 주소 공간과 물리 주소 공간을 분리 -> 변환을 위한 MMU 필요 
특징 : 외부단편화 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐. 

세그멘테이션 : 사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리를 사용하는 시점에 할당됨. 

세마포오 : 운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호 공유 자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능 스레드들은 리소스 접근 요청을 할 수 있고, 세마포오는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우 다음 작업은 대기를 하게 된다. -> 즉 카운트를 사용해서 동기화 관리

뮤텍스 : 상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫번째 스레드가 해당 섹션을 빠져나올 때 까지 기다리는 것 -> busy waiting

세마와 뮤텍스 차이점 : 세마포오는 뮤텍스가 될 수 있지만 뮤텍스는 세마포오가 될 수 없음 -> 카운트를 1로 설정하면됨 
세마포오는 소유 불가능 , 뮤텍스는 소유 가능
동기화 개수가 다름


## Context Switching 
하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작접 -> 한 프로세스의 문맥은 그 프로세스의 PCB 에 기록됨 

## 사용자 수준 스레드와 커널 수준 스레드 차이 

사용자 수준 스레드(user level thread) : 
장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음(스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨(커널이 스레드의 존재를 알지 못하기 때문)

커널 수준 스레드(kernel level thread) 
장점 : user level보다 효율적. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 cpu가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 cpu에 효율적으로 스레드 배당할 수 없음. 
단점 : context switching 이 발생. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다. 

## 가상 메모리란 
-> 프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있다. 따라서 메모리는 실제 + 가상 메모라고 생각하면 안된다. 

메모리가 부족해서 가상메모리가 사용되는건 맞지만, 가상메모리를 쓴다고 실제 메모리 처럼 사용되는 것은 아님. ㅇ

실제 메모리안에 공간이 부족하면, 현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할 

즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것이고 그걸 도와주는게 가상메모리

## fork() vfork() 차이점
fork()는 부모 프로세스의 메모리를 복사해서 사용 
vfotk()는 부모 프로세스와의 메모리를 공유 -> 복사하지 않기 때문에 생성 속도 빠름 . 하지만 자원을 공유하기 때문에 face condition이 발생하지 않도록 부모프로세스는 자식프로세스가 exit하거나 execute가 호출되기 전까지 block됨

## Race Condition
-> 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능.
