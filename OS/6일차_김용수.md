## Chapter5. 09. CPU 스케쥴링
- CPU 스케쥴링은 멀티 프로그래밍을 기초로 할 것
- 멀티 프로그래밍의 목적은 프로세스가 항상 돌게하고, CPU 사용률을 높이기 위함
- CPU를 사용하는 시간을 CPU burst, I/O를 기다리는 시간을 I/O burst
- CPU burst 타임이 늘어나면 효율이 좋아지다가 특정 수준에서 부터는 안좋아짐
- cpu 스케쥴러는 메모리에 있는 프로세스(ready 상태)중에 다음에 cpu에 할당할 프로세스를 선택해줌
- 다음 프로세스를 고르는 것은 fifo queue나 priority queue를 이용해서 만들 수 있음
- 선점형과 비선점형이 존재
  - 선점형은 cpu를 프로세스가 선정하고 있어도 우선순위가 높으면 쫓아낼 수 있음
  - 비선점형은 한 프로세스가 cpu를 잡고있으면 그 프로세스가 동작을 끝내고 나갈때까지 쫓아내지 못함
- 프로세스에게 cpu를 넘겨주는 역할을 하는게 dispatcher
- 디스패처는 빠르면 빠를수록 좋음(디스패처 latency가 가능하면 짧아야함)
- 스케쥴링의 목표
  - cpu 효율성 : cpu를 가장 바쁘게 유지
  - 처리량 : 단위시간에 처리하는 프로세스의 수를 최대화
  - turnaround time : 프로세스가 실행되고 완료될때까지의 시간을 최소화
  - waiting time : 프로세스가 레디 큐에서의 대기시간을 최소화
- cpu 스케쥴링 문제는 ready 큐에 있는 어떤 프로세스를 할당할 것인가
- 스케쥴링의 종류
  - fcfs : 먼저온 프로세스 먼저 처리
  - sjf : 가장 짧은 프로세스 먼저 처리(srtf : 남은 시간이 가장 적은 프로세스 우선)
  - rr : 라운드로빈(시분할을 해서 정해진 시간동안만 사용하고 다시 ready 큐로)
  - priority-based : 우선순위 기반
  - MLQ : 멀티 레벨 큐
  - mlfq : 멀티 레벨 피드백 큐
- FCFS : 먼저 들어온 프로세스 먼저 처리
  - 굉장히 구현하기 쉬움
  - 먼저 들어온 프로세스가 CPU burst 시간이 길면 waiting time, throughput 효율이 안좋음
  - 컨보이 효과가 발생(앞에 한개가 막혀있으니까 뒤에서 다 멈춰있음)
- SJF : CPU burst 타임이 가장 짧은 프로세스를 할당
  - waiting time이나 throughput이 fcfs 보다 훨씬 줄어듬

## Chapter5. 10. 스케쥴링 알고리즘
- SJF는 무조건 평균 waiting time이 가장 작음
- 단, cpu burst 시간이 긴 프로세스는 waiting time이 늘어남
- 최적의 알고리즘이지만 다음 cpu burst time을 알 수 있는 방법이 없기 때문에 구현할 수 없는 알고리즘임
- 과거의 cpu burst time을 통해서 지수적인 평균을 구할 수 있음
- 최근의 cpu burst time을 더 가중치를 줘서 계산
- 가중치를 1로 주면 가장 최근것만, 0으로 주면 가장 최근것은 배제해서 cpu burst time을 구함
- sjf 는 선점형일수도 있고, 비선점형일수도 있음
- SRTF : 남은 시간이 가장 짧은 프로세스를 수행
  - 새로 Ready 큐로 들어온 프로세스가 지금 수행중인 프로세스보다 남은 시간이 더 짧으면 선점함
  - waiting time은 srtf 가 선점을 못하는 sjf 보다 더 짧음
- RR : 타임 쉐어링 형태의 스케쥴링 방식
  - FCFS의 발전된 형태로 시간을 쪼개서 돌아가면서 수행
  - 프로세스가 CPU burst보다 짧으면 자발적으로 빠져나가고 다음 프로세스 실행, 프로세스가 더 길면 interrupt를 걸어서 ready큐로 넣어주고 다음 프로세스 실행
  - RR스케쥴링은 선점형 스케쥴링임
  - RR 알고리즘의 기간을 너무 길게 주면 FCFS랑 똑같다는 문제가 생기고, 너무 짧으면 Context Switch가 너무 많이 발생해서 문제가 생기므로 적당한 길이의 시간을 설정하는 것이 중요함
- Priority-base 스케쥴링
  - 각각의 프로세스에 우선순위를 할당하여 우선순위가 높은 프로세스부터 수행
  - 먼저들어오면 우선순위를 높게 준다고 하면 fcfs와 똑같음
  - sjf도 다음 cpu burst가 짧은 것을 우선순위를 높게 주는 우선순위 기반 스케쥴링이라고 할 수 있음
  - 선점형으로 할 것인가, 비선점으로 할 것인가를 정해줘야함
  - starvation 문제를 해결할 수 있어야함
  - 낮은 우선순위의 프로세스는 계속 레디큐에서 대기할 수 있음(aging 기법 필요)
- MLQ 스케쥴링
  - 큐를 여러개를 두어 수행
  - 큐들의 우선순위를 두어 더 우선 순위에 있는 큐에 들어있는 프로세스 수행하고 완료하면 순차적으로 아래의 큐의 프로세스들을 수행
  - 이것도 starvation 문제가 생길 수 있음
- Real time 운영체제의 스케쥴링
  - 소프트 리얼타임과 하드 리얼타임이 존재
  - 하드 리얼 타임은 어떤 테스크가 반드시 deadline 안에 수행


## Chapter5. 09-10: 퀴즈 #5
- 1번 : cpu 스케쥴러를 통해 cpu 할당해주는 모듈을 디스패처라고 함 - 1
- 2번 : 응답시간은 줄일수록 좋음 - 4
- 3번 : RR은 할당된 시간이 지나면 다시 READY 큐로 돌아감 - 4
- 4번 : 멀티레벨 피드백 큐는 큐가 여러개임 - 4
- 5번 : FCFS는 123 RR은 132순 - 3
- 6번 : 4+0+11 = 15/3 = 5 - 1
- 7번 : 19 + 6 + 4 + 20 = 49 / 4 = 12.25 - 3
- 8번 : 10 + 11 + 13 + 14 = 48 - 1, 1+ 5 + 3 + 9 + 9 = 27 - 3