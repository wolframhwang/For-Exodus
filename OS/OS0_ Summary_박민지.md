### Ch01 운영체제의 개요

* 운영체지의 정의   
사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리           
   
* 운영체제의 역활/목표         
   
역할 | 목표
:---:|:---:
자원관리 | 효율성
자원보호 | 안정성
하드웨어 인터페이스 제공 | 확장성
사용자 인터페이스 제공 | 편리성

* 운영체제의 역사
구분 | 시기 | 기술 | 특징
:---: | :---: | :---: | :---: 
0기 | 1940년대 | X | 진공관 사용(0과1)   
1기 | 1950년대 | 카드 리더, 라인 프린터 | 일괄 작업 시스템 / 운영체제의 등장   
2기 | 1960년대 | 키보드, 모니터 | 대화형 시스템   
3기 | 1970년대 | C언어 | 시분할 시스템 / 다중 프로그래밍 기술개발   
4기 | 1980년대 | PC | 분산 시스템 / 개인용 컴퓨터의 등장      
5기 | 1990년대 | 웹 | 클라이언트/서버 시스템   
6기 | 2000년대 | 스마트폰 | 그리드 컴퓨팅/ 클라우드 컴퓨팅/ 사물인터넷  / P2P 시스템(메신저, 파일 공유)

*  운영체제의구성    
 - 인터페이스 : 커널에 명령전달, 실행결과를 사용자와 응용프로그램에 돌려줌
 - 커널 : 운영체제의 핵심 기능을 모아놓음

* 커널의 종류    
 - 단일형 구조 커널 : 커널의 핵심 기능을 구현하는 모듈들이 구분없이 하나로 구성   
 - 계층형 구조 커널 : 비슷한 기능을 가진 모듈을 묶어 하나의 걔층으로 형성, 계층 간의 통신을 통해 운영체제 구현   
 - 마이크로 구조 커널 : 프로세스관리, 메모리 관리, 프로세스 간 통신 관리등 가장 기본적인 기능만 운영체제가 제공   

====

### Ch02 컴퓨터의 구조와 성능 향상

* 하드웨의 구성   
컴퓨터 : 필수장치(CPU + 메인메모리) + 주변장치(입력장치 + 출력장치 + 저장장치)   

* 폰노이만 구조   
CPU, 메모리, 입출력장치, 저장장치가 버스로 연결   
모든 프로그램이 메모리와 올라와야 실행가능   

* CPU
명령어를 해석하여 실행하는 장치   
산술논리 연산장치 + 제어장치 + 레지스터   

* 메모리
실행에 필요한 프로그램과 데이터를 저장하는 공간   
모든 프로그램은 메모리에 올라와야 실행 가능   
램(읽기 쓰기 가능) / 롬(읽기만 가능)

* 부팅
운영체제를 메모리에 올리는 과정   
전원On -> 바이오스(롬에 저장되어 있음) 실행 -> 하드웨어 점검 -> 메모리에 부트스트랩 코드를 올려 실행 -> 부트스트랩 코드는 운영체제(하드디스크에 저장되어 있음)를 메모리로 가져와 실행   

* 버퍼
일정량의 데이터를 모아 옮겨서 두 장치 사이에서 속도의 차이를 완화하는 역할   

* 캐시
메모리와 CPU간의 속도를 완화하기 위해 데이터를 미리 가져와 저장해두는 임시장소   
사용할 것으로 예상되는 데이터를 미리 가져다놓음으로 두 장치의 속도 차이 완화

* 저장장치의 계층구조   
속도 빠르고 값이 비싼 저장장치를 CPU 가까운 쪽에 두고 값이 싸고 용량이 큰 장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻는 방법

* 인터럽트   
CPU  -> 작업지시 -> 입출력 관리자 -> 완료신호(인터럽트) -> CPU   
입출력 관리자가 CPU에게 보내는 완료신호   
CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영 -> 시스템의 효율 증가       

* 병렬처리   
동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식     
- CPU에서 명령어가 처리되는 과정 : 명령어 패치 -> 명령어 해석 -> 실행 -> 쓰기    

====

### Ch03 프로세스와 스레드

* 프로그램과 프로세스
 - 프로그램 : 저장장치에 저장되어 있는 정적인 상태   
 - 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태

* 프로세스의 상태   
 - 생성 상태 : 프로그램을 메모리에 가져와 실행 준비 완료         
 - 준비 상태 : 실행될 프로세스를 CPU스케줄러가 선택 / 모든 프로세스가 자기 차례를 기다림    
 - 실행 상태 : 선택된 프로세스가 타임 슬라이스를 얻어 CPU사용 상태 / 프로세스 사이의 문맥 교환이 일어남    
 - 대기 상태 : 실행 상태인 프로세스가 입출력을 요청하면 입출력이 완료될때까지 기다리는 상태 / 입출력이 완료되면 다시 준비 상태로 감     
 - 완료 상태 : 프로세스가 종료된 상태 / 사용하던 모든 데이터가 정리 /exit(정상 종료), abort(비정상종료)    

* 프로세스 제어 블록      
프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조, 모든 프로세스는 고유의 프로세스 제어 블록을 가짐    
프로세스 생성시 만들어졌다가 프로세스가 실행을 완료하면 폐기     

* 문맥 교환    
- 두 프로세스의 프로세스 제어 블록 및 이와 관련값들을 교환화는 작업    
- 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생     
- 인터럽트가 걸렸을 때도 발생

* 프로세스의 복사와 전환
- fork() 시스템 호출 : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수   
- exec() 시스템 호출 : 기존의 프로세스르 새로운 프로세스로 전환하는 함수   

* 프로세스의 계층구조   
부모 프로세스를 복사하여 자식 프로세스를 만드는 방법 / 프로세스끼리 계층 구조를 갖는 것    
부모 프로세스는 자신의 자원을 자식 프로세스에 상속하고 자식 프로세스가 종료되면 자원 회수    

* 스레드    
CPU 스케줄러가 CPU에 전달하는 일 하나,    
하나의 프로세스에는 여러개의 스레드가 존재 

* 스레드 관련 용어
- 멀티스레드 : 멀티 스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로 작업의 부담을 줄이는 프로세스 운영 기법    
- 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법     
- 멀티프로세싱 : CPU를 여러개 사용하여 여러개의 스레드를 동시에 처리하는 작업 환경   
- CPU 멀티스레드 : 원래는 한번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법     

* 멀티스레드의 장점    
- 응답성 향상 : 한 스레드가 작업이 진행중이지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답 가능






     



