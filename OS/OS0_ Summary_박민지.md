### Ch01 운영체제의 개요

* 운영체제의 정의   
사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리           
   
* 운영체제의 역할/목표         
   
역할 | 목표
:---:|:---:
자원관리 | 효율성
자원보호 | 안정성
하드웨어 인터페이스 제공 | 확장성
사용자 인터페이스 제공 | 편리성

* 운영체제의 역사

구분 | 시기 | 기술 | 특징
:---: | :---: | :---: | :---: 
0기 | 1940년대 | X | 진공관 사용(0과1)   
1기 | 1950년대 | 카드 리더, 라인 프린터 | 일괄 작업 시스템 / 운영체제의 등장   
2기 | 1960년대 | 키보드, 모니터 | 대화형 시스템   
3기 | 1970년대 | C언어 | 시분할 시스템 / 다중 프로그래밍 기술개발   
4기 | 1980년대 | PC | 분산 시스템 / 개인용 컴퓨터의 등장      
5기 | 1990년대 | 웹 | 클라이언트/서버 시스템   
6기 | 2000년대 | 스마트폰 | 그리드 컴퓨팅/ 클라우드 컴퓨팅/ 사물인터넷  / P2P 시스템(메신저, 파일 공유)

*  운영체제의구성    
    - 인터페이스 : 커널에 명령전달, 실행결과를 사용자와 응용프로그램에 돌려줌
    - 커널 : 운영체제의 핵심 기능을 모아놓음

* 커널의 종류    
    - 단일형 구조 커널 : 커널의 핵심 기능을 구현하는 모듈들이 구분없이 하나로 구성   
    - 계층형 구조 커널 : 비슷한 기능을 가진 모듈을 묶어 하나의 걔층으로 형성, 계층 간의 통신을 통해 운영체제 구현   
    - 마이크로 구조 커널 : 프로세스관리, 메모리 관리, 프로세스 간 통신 관리등 가장 기본적인 기능만 운영체제가 제공   

***

### Ch02 컴퓨터의 구조와 성능 향상

* 하드웨의 구성   
컴퓨터 : 필수장치(CPU + 메인메모리) + 주변장치(입력장치 + 출력장치 + 저장장치)   

* 폰노이만 구조   
CPU, 메모리, 입출력장치, 저장장치가 버스로 연결   
모든 프로그램이 메모리와 올라와야 실행가능   

* CPU
명령어를 해석하여 실행하는 장치   
산술논리 연산장치 + 제어장치 + 레지스터   

* 메모리
실행에 필요한 프로그램과 데이터를 저장하는 공간   
모든 프로그램은 메모리에 올라와야 실행 가능   
램(읽기 쓰기 가능) / 롬(읽기만 가능)

* 부팅
운영체제를 메모리에 올리는 과정   
전원On -> 바이오스(롬에 저장되어 있음) 실행 -> 하드웨어 점검 -> 메모리에 부트스트랩 코드를 올려 실행 -> 부트스트랩 코드는 운영체제(하드디스크에 저장되어 있음)를 메모리로 가져와 실행   

* 버퍼
일정량의 데이터를 모아 옮겨서 두 장치 사이에서 속도의 차이를 완화하는 역할   

* 캐시
메모리와 CPU간의 속도를 완화하기 위해 데이터를 미리 가져와 저장해두는 임시장소   
사용할 것으로 예상되는 데이터를 미리 가져다놓음으로 두 장치의 속도 차이 완화

* 저장장치의 계층구조   
속도 빠르고 값이 비싼 저장장치를 CPU 가까운 쪽에 두고 값이 싸고 용량이 큰 장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻는 방법

* 인터럽트   
CPU  -> 작업지시 -> 입출력 관리자 -> 완료신호(인터럽트) -> CPU   
입출력 관리자가 CPU에게 보내는 완료신호   
CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영 -> 시스템의 효율 증가       

* 병렬처리   
동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식     
    - CPU에서 명령어가 처리되는 과정 : 명령어 패치 -> 명령어 해석 -> 실행 -> 쓰기    

*** 

### Ch03 프로세스와 스레드

* 프로그램과 프로세스
    - 프로그램 : 저장장치에 저장되어 있는 정적인 상태   
    - 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태

* 프로세스의 상태   
    - 생성 상태 : 프로그램을 메모리에 가져와 실행 준비 완료         
    - 준비 상태 : 실행될 프로세스를 CPU스케줄러가 선택 / 모든 프로세스가 자기 차례를 기다림    
    - 실행 상태 : 선택된 프로세스가 타임 슬라이스를 얻어 CPU사용 상태 / 프로세스 사이의 문맥 교환이 일어남    
    - 대기 상태 : 실행 상태인 프로세스가 입출력을 요청하면 입출력이 완료될때까지 기다리는 상태 / 입출력이 완료되면 다시 준비 상태로 감     
    - 완료 상태 : 프로세스가 종료된 상태 / 사용하던 모든 데이터가 정리 /exit(정상 종료), abort(비정상종료)    

* 프로세스 제어 블록      
프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조, 모든 프로세스는 고유의 프로세스 제어 블록을 가짐    
프로세스 생성시 만들어졌다가 프로세스가 실행을 완료하면 폐기     

* 문맥 교환    
    - 두 프로세스의 프로세스 제어 블록 및 이와 관련값들을 교환화는 작업    
    - 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생     
    - 인터럽트가 걸렸을 때도 발생

* 프로세스의 복사와 전환
    - fork() 시스템 호출 : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수   
    - exec() 시스템 호출 : 기존의 프로세스르 새로운 프로세스로 전환하는 함수   

* 프로세스의 계층구조   
부모 프로세스를 복사하여 자식 프로세스를 만드는 방법 / 프로세스끼리 계층 구조를 갖는 것    
부모 프로세스는 자신의 자원을 자식 프로세스에 상속하고 자식 프로세스가 종료되면 자원 회수    

* 스레드    
CPU 스케줄러가 CPU에 전달하는 일 하나,    
하나의 프로세스에는 여러개의 스레드가 존재 

* 스레드 관련 용어
    - 멀티스레드 : 멀티 스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로 작업의 부담을 줄이는 프로세스 운영 기법    
    - 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법     
    - 멀티프로세싱 : CPU를 여러개 사용하여 여러개의 스레드를 동시에 처리하는 작업 환경   
    - CPU 멀티스레드 : 원래는 한번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법     

* 멀티스레드의 장점    
    - 응답성 향상 : 한 스레드가 작업이 진행중이지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답 가능   
    - 자원공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 원활한 작업 진행 가능   
    - 효율성 향상 : 불필요한 자원의 중복을 막는다   
    - 다중 CPU지원 : 2개 이상의 CPU을 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU사용량이 증가하고 프로세스의 처리 시간이 단축

* 멀티스레드 모델    
    - 사용자 레벨 스레드 : 사용자 레벨에서 관련 라이브러리를 사용하여 구현,     
        라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현    
    - 커널 레벨 스레드 : 커널이 멀티스레드를 지원하는 방식          
    - 멀티레벨 스레드 : 사용자 레벨 스레드 + 커널 레벨 스레드 / 하이브리드 스레드    

***

### Ch04 CPU스케줄링

* CPU스케줄링   
CPU  스케줄러가 하는 모든 작업         
[ CPU 스케줄러 :  프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정 ] 

* 스케줄링의 단계    
    - 고수준 스케줄링 : 시스템의 전체 프로세스 수를 조절    
    - 중간 수준 스케줄링 : 전 시스템의 활성화된 프로세스를 조절해서 과부하 방지     
    - 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등 결정    

* 스케줄링의 목적    
    - 공평성 : 자원을 공평하게 배정      
    - 효율성 : 시스템 자원이 유휴시간 없이 사용되도록 스케줄링, 유휴자원을 사용하려는 프로세스에 우선권 부여     
    - 안정성 : 우선순위를 사용해 중요 프로세스가 먼저 작동하도록 배정, 자원을 점유 또는 파괴하려는 프로세스로부터 자원 보호     
    - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치, 시스템 자원이 늘어나는 경우 시스템에 반영되도록 해야함     
    - 반응 시간 보장 : 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야함       
    - 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되면 안됨    

* 스케줄링 시 고려 사항
    - 우선순위가 높은 프로세스에 CPU먼저 할당
    - 우선순위 높 : 커널 프로세스, 전면 프로세스, 대화형 프로세스, 입출력 집중 프로세스      
    - 우선순위 낮 : 일반 프로세스, 후면 프로세스, 일괄 작업 프로세스, CPU 집중 프로세스       

* 다중 큐      
    큐를 여러개를 두어 관리하는 것(효율적으로 프로세스를 관리하기 위해)         
    - 준비상태 : 우선순위에 따라 다중 큐 운영     
    - 대기상태 : 같은 입출력을 요구한 프로세스로 다중 큐 운영    

* 스케줄링 알고리즘
 - 비선점형 알고리즘    
   - FCFS 스케줄링 : 준비 큐에 도착한 순서대로 할당    
   - SJF 스케줄링 : 준비 큐에 있는 프로세스 중 실행시간이 가장 짧은 작업부터 할당      
   - HRN 스케줄링 : CPU를 할당 받기 위해 기다린 시간과 CPU사용시간을 고려    
 - 선점형 알고리즘
   - 라운드 로빈 스케줄링 : 타임 슬라이스(할당받은 시간) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 차례를 기다림
   - SRT 스케줄링 : 기본적으로 라운드 로빈 스케줄링 사용, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업시간이 가장 작은 프로세스 선택 
   - 다단계 큐 스케줄링 : 우선순위에 따라 준비 큐를 여러개 사용              
      프로세스는 운영체제가 준 우선순위에 따라 해당 우선순위의 큐에 삽입되어 실행
   - 다단계 피드백 큐 스케줄링 : 다단계 큐 스케줄링과 기본적인 형태는 동일,        
     CPU사용 후 원래의 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어감
 - 모두 가능
    - 우선순위 스케줄링 : 프로세스는 중요도에 따라 우선순위를 갖는데 이러한 우선순위를 반영하여 CPU 할당

***

### Ch05 프로세스 동기화

* 프로세스 간 통신의 개념        
프로세스가 다른 프로세스와 데이터를 주고받는 것      
프로세스 내부 데이터 통신, 프로세스 간 데이터 통신, 네트워크를 이용한 데이터 통신     

* 프로세스 간 통신의 분류     

분류방식 | 종류 | 예 
:---: | :---: | :---: 
통신 방향에 따른 분류 | 양방향 통신 | 일반적 통신, 소켓 
통신 방향에 따른 분류 | 반양방향 통신 | 무전기 
통신 방향에 따른 분류 | 단뱡향 통신 | 전역변수, 파일, 파이프 
통신 구현 방식에 따른 분류 | 대기가 있는 통신(동기화 통신) | 파이프, 소켓 
통신 구현 방식에 따른 분류 | 대기가 없는 통신(비동기화 통신) | 전역 변수, 파일 

     



