## PART1 운영체제와 컴퓨터

### Ch01 운영체제의 개요

* 운영체제의 정의   
사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리           
   
* 운영체제의 역할/목표         
   
역할 | 목표
:---:|:---:
자원관리 | 효율성
자원보호 | 안정성
하드웨어 인터페이스 제공 | 확장성
사용자 인터페이스 제공 | 편리성

* 운영체제의 역사

구분 | 시기 | 기술 | 특징
:---: | :---: | :---: | :---: 
0기 | 1940년대 | X | 진공관 사용(0과1)   
1기 | 1950년대 | 카드 리더, 라인 프린터 | 일괄 작업 시스템 / 운영체제의 등장   
2기 | 1960년대 | 키보드, 모니터 | 대화형 시스템   
3기 | 1970년대 | C언어 | 시분할 시스템 / 다중 프로그래밍 기술개발   
4기 | 1980년대 | PC | 분산 시스템 / 개인용 컴퓨터의 등장      
5기 | 1990년대 | 웹 | 클라이언트/서버 시스템   
6기 | 2000년대 | 스마트폰 | 그리드 컴퓨팅/ 클라우드 컴퓨팅/ 사물인터넷  / P2P 시스템(메신저, 파일 공유)

*  운영체제의구성    
    - 인터페이스 : 커널에 명령전달, 실행결과를 사용자와 응용프로그램에 돌려줌
    - 커널 : 운영체제의 핵심 기능을 모아놓음

* 커널의 종류    
    - 단일형 구조 커널 : 커널의 핵심 기능을 구현하는 모듈들이 구분없이 하나로 구성   
    - 계층형 구조 커널 : 비슷한 기능을 가진 모듈을 묶어 하나의 걔층으로 형성, 계층 간의 통신을 통해 운영체제 구현   
    - 마이크로 구조 커널 : 프로세스관리, 메모리 관리, 프로세스 간 통신 관리등 가장 기본적인 기능만 운영체제가 제공   

***

### Ch02 컴퓨터의 구조와 성능 향상

* 하드웨의 구성   
컴퓨터 : 필수장치(CPU + 메인메모리) + 주변장치(입력장치 + 출력장치 + 저장장치)   

* 폰노이만 구조   
CPU, 메모리, 입출력장치, 저장장치가 버스로 연결   
모든 프로그램이 메모리와 올라와야 실행가능   

* CPU
명령어를 해석하여 실행하는 장치   
산술논리 연산장치 + 제어장치 + 레지스터   

* 메모리
실행에 필요한 프로그램과 데이터를 저장하는 공간   
모든 프로그램은 메모리에 올라와야 실행 가능   
램(읽기 쓰기 가능) / 롬(읽기만 가능)

* 부팅
운영체제를 메모리에 올리는 과정   
전원On -> 바이오스(롬에 저장되어 있음) 실행 -> 하드웨어 점검 -> 메모리에 부트스트랩 코드를 올려 실행 -> 부트스트랩 코드는 운영체제(하드디스크에 저장되어 있음)를 메모리로 가져와 실행   

* 버퍼
일정량의 데이터를 모아 옮겨서 두 장치 사이에서 속도의 차이를 완화하는 역할   

* 캐시
메모리와 CPU간의 속도를 완화하기 위해 데이터를 미리 가져와 저장해두는 임시장소   
사용할 것으로 예상되는 데이터를 미리 가져다놓음으로 두 장치의 속도 차이 완화

* 저장장치의 계층구조   
속도 빠르고 값이 비싼 저장장치를 CPU 가까운 쪽에 두고 값이 싸고 용량이 큰 장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻는 방법

* 인터럽트   
CPU  -> 작업지시 -> 입출력 관리자 -> 완료신호(인터럽트) -> CPU   
입출력 관리자가 CPU에게 보내는 완료신호   
CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영 -> 시스템의 효율 증가       

* 병렬처리   
동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식     
    - CPU에서 명령어가 처리되는 과정 : 명령어 패치 -> 명령어 해석 -> 실행 -> 쓰기    

*** 
## PART2 프로세스 관리

### Ch03 프로세스와 스레드

* 프로그램과 프로세스
    - 프로그램 : 저장장치에 저장되어 있는 정적인 상태   
    - 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태

* 프로세스의 상태   
    - 생성 상태 : 프로그램을 메모리에 가져와 실행 준비 완료         
    - 준비 상태 : 실행될 프로세스를 CPU스케줄러가 선택 / 모든 프로세스가 자기 차례를 기다림    
    - 실행 상태 : 선택된 프로세스가 타임 슬라이스를 얻어 CPU사용 상태 / 프로세스 사이의 문맥 교환이 일어남    
    - 대기 상태 : 실행 상태인 프로세스가 입출력을 요청하면 입출력이 완료될때까지 기다리는 상태 / 입출력이 완료되면 다시 준비 상태로 감     
    - 완료 상태 : 프로세스가 종료된 상태 / 사용하던 모든 데이터가 정리 /exit(정상 종료), abort(비정상종료)    

* 프로세스 제어 블록      
프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조, 모든 프로세스는 고유의 프로세스 제어 블록을 가짐    
프로세스 생성시 만들어졌다가 프로세스가 실행을 완료하면 폐기     

* 문맥 교환    
    - 두 프로세스의 프로세스 제어 블록 및 이와 관련값들을 교환화는 작업    
    - 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생     
    - 인터럽트가 걸렸을 때도 발생

* 프로세스의 복사와 전환
    - fork() 시스템 호출 : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수   
    - exec() 시스템 호출 : 기존의 프로세스르 새로운 프로세스로 전환하는 함수   

* 프로세스의 계층구조   
부모 프로세스를 복사하여 자식 프로세스를 만드는 방법 / 프로세스끼리 계층 구조를 갖는 것    
부모 프로세스는 자신의 자원을 자식 프로세스에 상속하고 자식 프로세스가 종료되면 자원 회수    

* 스레드    
CPU 스케줄러가 CPU에 전달하는 일 하나,    
하나의 프로세스에는 여러개의 스레드가 존재 

* 스레드 관련 용어
    - 멀티스레드 : 멀티 스레드는 프로세스 내 작업을 여러 개의 스레드로 분할함으로 작업의 부담을 줄이는 프로세스 운영 기법    
    - 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법     
    - 멀티프로세싱 : CPU를 여러개 사용하여 여러개의 스레드를 동시에 처리하는 작업 환경   
    - CPU 멀티스레드 : 원래는 한번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법     

* 멀티스레드의 장점    
    - 응답성 향상 : 한 스레드가 작업이 진행중이지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답 가능   
    - 자원공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 원활한 작업 진행 가능   
    - 효율성 향상 : 불필요한 자원의 중복을 막는다   
    - 다중 CPU지원 : 2개 이상의 CPU을 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU사용량이 증가하고 프로세스의 처리 시간이 단축

* 멀티스레드 모델    
    - 사용자 레벨 스레드 : 사용자 레벨에서 관련 라이브러리를 사용하여 구현,     
        라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현    
    - 커널 레벨 스레드 : 커널이 멀티스레드를 지원하는 방식          
    - 멀티레벨 스레드 : 사용자 레벨 스레드 + 커널 레벨 스레드 / 하이브리드 스레드    

***

### Ch04 CPU스케줄링

* CPU스케줄링   
CPU  스케줄러가 하는 모든 작업         
[ CPU 스케줄러 :  프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정 ] 

* 스케줄링의 단계    
    - 고수준 스케줄링 : 시스템의 전체 프로세스 수를 조절    
    - 중간 수준 스케줄링 : 전 시스템의 활성화된 프로세스를 조절해서 과부하 방지     
    - 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등 결정    

* 스케줄링의 목적    
    - 공평성 : 자원을 공평하게 배정      
    - 효율성 : 시스템 자원이 유휴시간 없이 사용되도록 스케줄링, 유휴자원을 사용하려는 프로세스에 우선권 부여     
    - 안정성 : 우선순위를 사용해 중요 프로세스가 먼저 작동하도록 배정, 자원을 점유 또는 파괴하려는 프로세스로부터 자원 보호     
    - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치, 시스템 자원이 늘어나는 경우 시스템에 반영되도록 해야함     
    - 반응 시간 보장 : 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야함       
    - 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되면 안됨    

* 스케줄링 시 고려 사항
    - 우선순위가 높은 프로세스에 CPU먼저 할당
    - 우선순위 높 : 커널 프로세스, 전면 프로세스, 대화형 프로세스, 입출력 집중 프로세스      
    - 우선순위 낮 : 일반 프로세스, 후면 프로세스, 일괄 작업 프로세스, CPU 집중 프로세스       

* 다중 큐      
    큐를 여러개를 두어 관리하는 것(효율적으로 프로세스를 관리하기 위해)         
    - 준비상태 : 우선순위에 따라 다중 큐 운영     
    - 대기상태 : 같은 입출력을 요구한 프로세스로 다중 큐 운영    

* 스케줄링 알고리즘
    - 비선점형 알고리즘    
        - FCFS 스케줄링 : 준비 큐에 도착한 순서대로 할당    
        - SJF 스케줄링 : 준비 큐에 있는 프로세스 중 실행시간이 가장 짧은 작업부터 할당      
        - HRN 스케줄링 : CPU를 할당 받기 위해 기다린 시간과 CPU사용시간을 고려    
    - 선점형 알고리즘
        - 라운드 로빈 스케줄링 : 타임 슬라이스(할당받은 시간) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 차례를 기다림
        - SRT 스케줄링 : 기본적으로 라운드 로빈 스케줄링 사용, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업시간이 가장 작은 프로세스 선택 
        - 다단계 큐 스케줄링 : 우선순위에 따라 준비 큐를 여러개 사용              
      프로세스는 운영체제가 준 우선순위에 따라 해당 우선순위의 큐에 삽입되어 실행
        - 다단계 피드백 큐 스케줄링 : 다단계 큐 스케줄링과 기본적인 형태는 동일,        
     CPU사용 후 원래의 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어감
    - 모두 가능
        - 우선순위 스케줄링 : 프로세스는 중요도에 따라 우선순위를 갖는데 이러한 우선순위를 반영하여 CPU 할당

***

### Ch05 프로세스 동기화

* 프로세스 간 통신의 개념        
프로세스가 다른 프로세스와 데이터를 주고받는 것      
프로세스 내부 데이터 통신, 프로세스 간 데이터 통신, 네트워크를 이용한 데이터 통신     

* 프로세스 간 통신의 분류     

분류방식 | 종류 | 예 
:---: | :---: | :---: 
통신 방향에 따른 분류 | 양방향 통신 | 일반적 통신, 소켓 
통신 방향에 따른 분류 | 반양방향 통신 | 무전기 
통신 방향에 따른 분류 | 단뱡향 통신 | 전역변수, 파일, 파이프 
통신 구현 방식에 따른 분류 | 대기가 있는 통신(동기화 통신) | 파이프, 소켓 
통신 구현 방식에 따른 분류 | 대기가 없는 통신(비동기화 통신) | 전역 변수, 파일 

* 프로세스 간 통신의 종류      
    - 전역 변수를 이용한 통신 : 공동으로 관리하는 메모리를 사용해 데이터 통신
    - 파일을 이용한 통신 : 저장장치에 파일을 읽고 쓰는 방법으로 통신
    - 파이프를 이용한 통신 : 운영체제가 제공하는 동기화 통신방식,       
    데이터 전송-> 파이프에 쓰기 연산  /  데이터 수신 -> 파이프에 읽기 연산    
    - 소켓을 이용한 통신 : 여러 컴퓨터에 있는 프로세스와 프로세스를 소켓으로 연결해 데이터 통신         
    데이터 전송 -> 소켓에 쓰기 연산  /   데이터 수신 -> 소켓에 읽기 연산

* 공유 자원          
여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 

* 임계구역         
공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역

* 임계구역 해결 조건
    - 상호 배제 : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없음
    - 한정 대기 : 어떤 프로세스도 무한대기해서는 안됨
    - 진행의 융통성 : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨

* 임계구역 해결 방법
    - 피터슨 알고리즘 / 데커 알고리즘 :       
     임계구역 해결 조건을 모두 만족하는 소프트웨어적인 해결방법
    - 세마포어 : 임계구역에 진입하기 전에 스위치를 사용중으로 놓고 임계구역에 들어가는 방법    
    - 모니터 : 세마포어 알고리즘을 자동으로 처리하도록 설계한 코드,       
     보호할 자원을 임계구역으로 숨기고 임계구역에서 작업할 수 있는 인터페이스만 제공하여 자원 보호    

***

### Ch06 교착상태

* 교착 상태      
2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태       
시스템 자원, 공유 변수(또는 파일), 응용 프로그램 사용시 발생 가능

* 자원 할당 그래프       
자원의 할당과 대기 상태를 한눈에 파악 할 수 있다        
프로세스가 어떤 자원을 사용중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현        

* 교착 상태 필요조건         
    - 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 함       
    - 비선점 : 한 프로세스가 사용 중인 자원은 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 함            
    - 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 함          
    - 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이뤄야 함    

* 식사하는 철학자 문제                    
철학자 4명이 동그란 식탁에 둘러앉아 식사를 하는데, 왼쪽에 있는 포크를 집은 위 오른쪽에 있는 포크를 잡아야만 식사가 가능하다는 조건이 있는 문제 

* 교착 상태 해결 방법               
    - 교착 상태 예방 : 4가지 조건이 발생하지 않도록 무력화     
    - 교착 상태 회피 : 자원 할당량을 조절해 교착 상태를 해결, 자원을 할당하다가 교착 상태를 유발할 가능성이 있다고 판단되면 자원 할당을 중지하고 지켜본다       
    - 교착 상태 검출과 회복 : 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식, 교착 상태가 발생하면 교착 상태 회복 단계가 진행

* 은행원 알고리즘     
교착 상태 회피를 구현하는 방법, 자원의 총 수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태와 불안정 상태로 나누고 시스템이 안정 상태를 유지하도록 자원 할당   

***
## PART3 메모리 관리

### Ch07 물리 메모리 관리

* 메모리 관리의 복잡성      
시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리 복잡

* 컴파일러               
    - 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행할 수 있도록 해주는 언어 번역 프로그램
    - 오류를 발견하고 코드를 최적화하기 위해 사용
    - 컴파일러 컴파일 -> 목적코드와 라이브러리 연결 -> 동적 라이브러리 포함해 최종 실행         

* 메모리 관리자의 정책       
    - 가져오기 정책 : 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정    
    - 배치 정책 : 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정      
    - 재배치 정책 : 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정

* 절대주소와 상대주소             
    - 절대 주소 : 실제 물리 주소, 메모리 관리자 입장에서 바라본 주소     
    - 상대 주소 : 사용자 영역이 시작된는 주소를 0번지로 변경하여 사용하는 주소      

* 메모리 오버레이     
 프로세스의 크기가 실제메모리(물리 메모리)보다 클 때 전체 프로세스를 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법

* 스왑        
 메모리가 부족해 쫓겨난 프로세스를 저장장치의 특별한 공간인 스왑영역에 모아두는 기법            
 스왑인 -> 스왑 영역에서 메모리로 데이터를 가져오는 작업            
 스왑아웃 -> 메모리에서 스왑 영역으로 데이터를 내보내는 작업

* 메모리 분할 방식          
    - 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나누는 것        
    - 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것        

* 외부 단편화와 내부 단편화     
    - 외부 단편화 : 프로세스의 크기 > 메모리 공간  ->  할당이 불가능한 현상
    - 내부 단편화 : 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상    

* 가변 분할 방식의 메모리 배치 방식       
    - 최초 배치 : 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫번째로 발견한 공간에 프로세스 배치         
    - 최적 배치 : 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스 배치             
    - 최악 배치 : 최적배치와 반대, 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스르 배치             

* 조각 모음       
 단편화가 발생하면 이미 배치된 프로세스르 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만드는 것       

***

### Ch08 가상 메모리의 기초

* 가상 메모리의 개념     
 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술    

* 가상 메모리의 크기    
 물리 메모리 + 스왑 영역

* 매핑 테이블    
 가상 주소가 물리 메모리의 어느 위치에 있는지 알 수 있도록 정리한 표

* 페이징 기법      
    - 고정 분할 방식을 이용한 가상 메모리 관리 기법, 물리 주소 공간을 같은 크기로 나누어 사용       
    - 페이지 : 가상 주소의 분할된 각 영역
    - 프레임 : 물리 메모리의 각 영역

* 페이지 테이블 매핑 방식     
    - 직접 매핑 : 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식    
    - 연관 매핑 : 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 물리 메모리의 공간이 작을 때 사용
    - 집합-연관 매팽 : 연관 매핑의 문제를 개선한 방식, 페이지 테이블을 일정한 집합으로 자르고 자른 덩어리 단위로 물리 메모리에 가져옴
    - 역매핑 : 물리 메모리의 프레임 번호를 기준으로 테이블 구성 

* 세그먼테이션 기법       
 가변 분할 방식을 이용한 가상 메모리 관리 기법, 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용

* 세그먼테이션-페이징 혼용 기법        
사용자 입장- 세그먼테이션 기법 사용, 메모리 관리자 입장 - 페이징 기법      
메모리 보호 및 중복 정보를 세그먼테이션 테이블에서 관리해서 메모리를 효율적 관리

***
### Ch09 가상 메모리 관리

* 요구 페이징       
사용자가 요청할 때 해당 페이지를 메모리로 가져오는 것

* 페이지 테이블 엔트리의 플래그 비트         
    - 접근 비트 : 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트    
    - 변경 비트 : 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트      
    - 유효 비트 : 페이지가 실제 메모리에 있는지 나타내는 비트   
    - 읽기, 쓰기, 실행비트 : 페이지에 대한 읽기, 쓰기, 실행 권한을 나타내는 비트

* 페이지 부재      
 프로세스가 페이지를 요청했을 때 그 페이지가 메모리가 없는 상황

* 지역성      
 - 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아닌 특정 영역에 집중되는 성질       
 - 공간의 지역성, 시간의 지역성, 순차적 지역성

* 페이지 교체 알고리즘         

종류 | 알고리즘 | 특징
:---: | :---: | :--- 
간단한 알고리즘 | 무작위 | 무작위로 대상 페이지를 선정해 스왑영역으로 보냄
간단한 알고리즘 | FIFO | 처음 메모리에 올라온 페이지를 스왑 영역으로 보냄
이론적 알고리즘 | 최적 | 미래의 접근 패턴을 보고 대상 페이지를 선정해 스왑 영역으로 보냄
최적 근접 알고리즘 | LRU | 시간적으로 머리 떨어진 페이지를 스왑 영역으로 보냄
최적 근접 알고리즘 | LFU | 사용 빈도가 적은 페이지를 스왑 영역으로 보냄
최적 근접 알고리즘 | NUR | 최근에 사용한 적 없는 페이지를 스왑 영역으로 보낸다 
최적 근접 알고리즘 | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높임

* 스레싱                   
 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태

* 프레임 할당 방식           
    - 정적 할당 : 프로세스 실행 초기에 프레임을 나눈 후 그 크기를 고정하는 방식       
    - 동적 할당 : 프로세스를 실행하는 중에 프레임을 나누어주기도 하고 회수하기도 하는 방식 

***

## PART4 저장장치 관리

### Ch10 입출력 시스템과 저장장치

* 입출력 버스의 구조       
    - 메인버스 : CPU + 메모리    
    - 그래픽 버스 : CPU + 그래픽 카드
    - 고속 입출력 버스
    - 저속 입출력 버스

* 직접 메모리 접근        
 CPU의 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한으로 입출력 제어기에는 직접 메모리에 접근하기 위한 DMA제어기가 마련되어 있음      

* 하드웨어 인터럽트        
 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알려주는 역할을 하는 신호 

* 디스크 장치의 전송 시간      
하드디스크에서 데이터를 가져오는데 걸리는 총시간 = 탐색시간 + 회전 지연 시간 + 전송 시간       

* 디스크 장치 관리    
    - 파티션 : 디스크를 논리적으로 분할       
    - 포매팅 : 디스크 표면을 초기화하는 작업      
    - 조각모음 : 디스크에 파일을 저장했다 지우기를 반복함으로써 중간에 생긴 빈 공간을 하나로 모으는 작업      

* 네트워크 저장장치     
    - DAS : 서버와 같은 컴퓨터에 직접 연결된 저장장치
    - NAS : 기존의 저장장치를 LAN이나 WAN에 붙여서 사용하는 방식    
    - SAN : 데이터 서버, 백업 서버, RAID 등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태    

* 디스크 스케줄링 기법         
    - FCFS 디스크 스케줄링 : 트랙 요청이 들어온 순서대로 서비스 
    - SSTF 디스크 스케줄링 : 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 서비스, 거리가 같다면 먼저 요청받은 트랙 서비스
    - 블록 SSTF 디스크 스케줄링 :  SSTF 디스크 스케줄링에 에이징 적용
    - SCAN 디스크 스케줄링 : 헤드가 움직이기 시작하면 맨 마지막 트랙에 도착할 때까지 뒤돌아가지 않고 계속 앞으로만 전전하면서 요청받은 트랙을 서비스     
    SSTF 디스크 스케줄링의 공평성 위배를 완화하기 위한 기법
    - C-SCAN 디스크 스케줄링 : 헤드가 한쪽 방향으로 움직일 때는 요청 받은 트랙을 서비스하지만 반대 방향으로 돌아올 때는 서비스하지 않고 헤드만 이동
    - LOOK 디스크 스케줄링 : 서비스할 트랙이 없으면 헤드가 끝까지 가지 않고 중간에서 방향을 바꿈
    - C-LOOK 디스크 스케줄링 : C-SCAN 디스크 스케줄링의 LOCK버전, 서비스할 트랙이 없으면 헤드가 중간에서 방향을 바꾼다
    - SLTF 디스크 스케줄링 : 헤드가 고정된 저장장치에서 사용하는 스케줄링 기법,       
    작업 요청이 들어온 섹터의 순서를 디스크가 회전하는 방향에 맞추어 다시 정렬한 후 서비스      

    * RAID      
        - 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템, 동일한 규격의 디스크를 여러개 모아 구성, 장애가 발생했을 때 데이터를 복구하는데 사용
        - 디스크 구성방식에 따라 RAID 0, 1, 2, 3, 4, 5, 6, 0+1, 10, 50, 60 등

***

### Ch11 파일시스템

* 파일시스템      
파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 하는 시스템      상태        사용자의 요청에 따라 파일을 저장하거나 파일의 내용을 읽어옴      

* 파일구조      
    - 순차 파일 구조 :  하나의 긴 줄로 늘어선 형태로 저장되어 있음, 순차 접근만 가능     
    - 인덱스 파일 구조 : 순차 파일 구조에 인덱스 테이블을 추가, 순차 접근과 직접 접근 가능    
    - 직접 파일 구조 : 저장하는 데이터의 특정 값이 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 구조

* 디렉터리      
 관련 있는 파일을 하나로 모아놓은 곳, 하나의 디렉터리에는 여러개의 파일과 자식 디렉터리가 존재     

* 디스크 파일 할당 방식     
    - 연속 할당 : 디스크상에 연속적으로 배열하는 간단한 방식
    - 불연속 할당 : 빈 블록에 데이터를 분산해 저장하고 이 정보를 파일 시스템이 관리하는 방식
        - 연결 할당 : 연결 리스트 이용
        - 인덱스 할당 : 인덱스를 이용

* 디스크의 빈 공간 관리     
파일시스템은 디스크의 내부 단편화를 줄이고 빈 공간을 효율적으로 관리하기 위해 빈 블록의 정보만 모아놓은 빈 공간 리스트를 유지함           
디스크에 빈 블록이 생기면 빈 공간 리스크에 추가되고, 빈 공간 리스트를 보고 새로운 블록을 할당할 때는 리스트에 먼저 들어온 블록부터 할당

***

## PART5 분산 시스템

### Ch12 네트워크와 분산 시스템

* 통신 방향에 따른 통신의 분류       
    - 단방향 통신 : 한쪽 방향으로만 통신,  모스부호,라디오,TV방송
    - 양방향 통신 : 양쪽 방향으로 동시에 통신이 이루어지는 방식,  전화
    - 반양방향 통신 : 단방향 통신과 양방향 통신의 중간 형태, 무전기

* 무선 전화망의 발전

종류 | 내용
:---: | :---: 
1G | 아날로그 음성 통화
2G | 디지털 음성 통화
3G | 음성통화 + 데이터 통신
LTE 3.9G | 4G 데이터 통신 + 3G 음성 통화 
4G | 고속 데이터 통신 + 음성통화
5G | 초고속 데이터 통신 + 음성통화

* 인터넷        
    - 1960년대 : 미국 국방성, 서로 호환되지 않는 LAN을 묶어 아르파넷 탄생
    - 인터넷은 네트워크를 하나로 묶는 기술

* 분산 시스템     
    - 클라이언트/ 서버 시스템 : 네트워크의 모든 컴퓨터가 동일한 지위 X, 클라이언트(작업 요청)/ 서버(작업을 처리)로 구성된 시스템
    - P2P 시스템 : 일대일로 연결된 말단 노드를 통해 실제 데이터 전송이 이루어지는 시스템
    - 클라우드 컴퓨팅 : 서버에 응용 프로그램과 데이터를 저장해두고 언제 어디서나 자유롭게 사용할 수 있는 시스템

***

     

출처 : 쉽게 배우는 운영체제. 조성호

